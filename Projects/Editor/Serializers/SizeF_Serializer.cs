// This File Has Generated By Compiler, Do Not Change It Manually
using VisualScriptTool.Serialization;
using VisualScriptTool.Reflection;
namespace VisualScriptTool.Editor.Serializers
{
	class SizeF_Serializer : Serializer
	{
		public override System.Type Type
		{
			get { return typeof(System.Drawing.SizeF); }
		}

		public override object CreateInstance()
		{
			return new System.Drawing.SizeF(0, 0);
		}

		public override void Serialize(ISerializeData Data, object Instance)
		{
			if (Data == null || Instance == null)
				throw new System.ArgumentNullException("Data and/or Instance cannot be null");
			System.Type instanceType = Instance.GetType();
			if (instanceType.IsArray())
				instanceType = instanceType.GetArrayElementType();
			else if (instanceType.IsList())
				instanceType = instanceType.GetListElementType();
			if (Type != instanceType)
				throw new System.InvalidCastException("Expected [" + Type.FullName + "]");
			instanceType = Instance.GetType();
			if ((Data is ISerializeObject && instanceType.IsArrayOrList()) || (Data is ISerializeArray && !instanceType.IsArrayOrList()))
				throw new System.ArgumentException("Data and Instance mismatch [" + Type.FullName + "]");
			ReferenceTable references = new ReferenceTable();
			SerializeInternal(Data, Instance, instanceType, references);
		}

		public override T Deserialize<T>(ISerializeData Data)
		{
			if (Data == null)
				throw new System.ArgumentNullException("Data cannot be null");
			GUIDTable references = new GUIDTable();
			ResolverList resolverList = new ResolverList();
			T returnValue = DeserializeInternal<T>(Data, references, resolverList);
			for (int i = 0; i < resolverList.Count; ++i)
				resolverList[i].Reslve(references);
			return returnValue;
		}

		public override void SerializeInternal(ISerializeData Data, object Instance, System.Type InstanceType, ReferenceTable References)
		{
			if (InstanceType.IsArrayOrList())
			{
				ISerializeArray Array = (ISerializeArray)Data; 
				System.Drawing.SizeF[] SizeFArray = null;
				if (InstanceType.IsArray())
					SizeFArray = (System.Drawing.SizeF[])Instance;
				else
					SizeFArray = ((System.Collections.Generic.List<System.Drawing.SizeF>)Instance).ToArray();
				for (int i = 0; i < SizeFArray.Length; ++i)
				{
					System.Drawing.SizeF element = SizeFArray[i];
					ISerializeObject elementObject = AddObject(Array); 
					System.Type elementType = element.GetType();
					Set(elementObject, 1, elementType.AssemblyQualifiedName);
					GetSerializer(elementType).SerializeInternal(AddObject(elementObject, 2), element, elementType, References); 
				}
			}
			else
			{
				ISerializeObject Object = (ISerializeObject)Data; 
				System.Drawing.SizeF SizeF = (System.Drawing.SizeF)Instance;
				// Width
				Set(Object, 0, SizeF.Width);
				// Height
				Set(Object, 1, SizeF.Height);
			}
		}

		public override T DeserializeInternal<T>(ISerializeData Data, GUIDTable References, ResolverList ResolverList)
		{
			T returnValue = default(T);
			if (Data is ISerializeArray)
			{
				ISerializeArray Array = (ISerializeArray)Data; 
				System.Drawing.SizeF[] SizeFArray = (System.Drawing.SizeF[])System.Array.CreateInstance(Type, Array.Count);
				for (uint i = 0; i < Array.Count; ++i)
				{
					ISerializeObject arrayObj = Get<ISerializeObject>(Array, i);
					System.Type targetType = System.Type.GetType(Get<string>(arrayObj, 1));
					SizeFArray[i] = GetSerializer(targetType).DeserializeInternal<System.Drawing.SizeF>(Get<ISerializeObject>(arrayObj, 2), References, ResolverList); 
				}
				returnValue = (T)(object)SizeFArray;
			}
			else
			{
				ISerializeObject Object = (ISerializeObject)Data; 
				System.Drawing.SizeF SizeF = (System.Drawing.SizeF)CreateInstance();
				// Width
				SizeF.Width = Get<System.Single>(Object, 0, 0);
				// Height
				SizeF.Height = Get<System.Single>(Object, 1, 0);
				returnValue = (T)(object)SizeF;
			}
			return returnValue;
		}

	}
}